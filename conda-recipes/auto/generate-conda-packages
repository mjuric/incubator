#!/usr/bin/env python

import os, os.path, shutil, subprocess
import conda_api
from collections import OrderedDict, namedtuple

ProductInfo = namedtuple('ProductInfo', ['conda_name', 'version', 'buildstring', 'deps'])

output_dir = "pkgs"

def fill_out_template(dest_file, template_file, **variables):
	# fill out meta.yaml
	with open(template_file) as fp:
		template = fp.read()

	text = template % variables

	with open(dest_file, 'w') as fp:
		fp.write(text)

def create_deps_string(deps, SEP='\n    - '):
	return (SEP + SEP.join([dep.lower() for dep in deps])) if deps else ''

def eups_to_conda_version(version):
	# Convert EUPS version string to Conda-compatible pieces
	if '+' in version:
		version, buildnum = version.split('+')
	else:
		buildnum = 0
	if '-' in version:
		version = version.replace('-', '_')

	return version, buildnum

def eups_to_conda_version_spec(conda_name, version, build_string="py27", *_):
	version, buildnum = eups_to_conda_version(version)
	if version != 'unknown':
		return "%s %s %s_%s" % (conda_name, version, build_string, buildnum)
	else:
		return conda_name

def gen_conda_package(product, sha, eups_version, eups_deps):
	#
	# process dependencies
	#
	if set(eups_deps) & internal_products:	# if we have any of the internal dependencies, make sure we depend on legacy_config where their .cfg and .table files are
		eups_deps += [ 'legacy_configs' ]
	deps =  [ eups_to_conda_map[prod] for prod in eups_deps if prod not in skip_products ]	# transform to Anaconda product names
	deps += add_missing_deps(conda_name, output_dir)						# manually add any missing dependencies

	# flatten dependencies to work around a Conda bug:
	# https://github.com/conda/conda/issues/918
	def flatten_deps(deps, seen=None):
		if seen is None:
			seen = set()

		fdeps = set(deps)
		for dep in deps:
			if dep not in seen:
				try:
					pi = products[dep]
				except KeyError:
					pass
				else:
					fdeps |= flatten_deps(pi.deps, seen)
				seen.add(dep)
		return fdeps
	build_deps = sorted(flatten_deps(deps))
	run_deps   = sorted(flatten_deps(deps))

	# What do we call this product in conda?
	conda_name = conda_name_for(product)

	# parse version
	version, buildnum = eups_to_conda_version(eups_version)

	# meta.yaml
	build_deps = [ eups_to_conda_version_spec(p, products[p].version, products[p].buildstring) if p in products else p for p in build_deps ]
	run_deps   = [ eups_to_conda_version_spec(p, products[p].version, products[p].buildstring) if p in products else p for p in run_deps ]

	build_req = create_deps_string(build_deps)
	run_req   = create_deps_string(run_deps)

	giturl = 'https://github.com/LSST/%s' % (product)

	#
	# Create the Conda packaging specs
	#
	dir = os.path.join(output_dir, conda_name)
	os.makedirs(dir)

	fill_out_template(os.path.join(dir, 'meta.yaml'), 'meta.yaml.template',
		productNameLowercase = conda_name.lower(),
		version = version,
		buildnum = buildnum,
		gitrev = sha1,
		giturl = giturl,
		build_req = build_req,
		run_req = run_req,
	)

	# build.sh (TBD: use exact eups versions, instead of -r .)
	setups = []
	SEP = 'setup '
	setups = SEP + ('\n'+SEP).join(setups) if setups else ''

	fill_out_template(os.path.join(dir, 'build.sh'), 'build.sh.template',
		setups = setups
	)

	# deduce the build string
	build_string = 'np19py27' if 'numpy' in (build_deps + run_deps) else 'py27'

	# record we've seen this product
	products[product] = ProductInfo(conda_name, version, build_string, deps)

def load_manifest(fn):
	with open(fn) as fp:
		lines = fp.read().split('\n')

	lines = lines[2:]
	for line in lines:
		line = line.strip()
		if not line:
			continue
		if line.startswith('#'):
			continue

		try:
			(product, sha, version, deps) = line.split()
			deps = deps.split(',')
		except ValueError:
			(product, sha, version) = line.split()
			deps = []

		yield (product, sha, version, deps)

# Products that already exist in Anaconda
internal_products = set("python swig libevent flask twisted scons numpy protobuf matplotlib".split())

# Products to skip
skip_products = set("anaconda afwdata".split())

# Products that need to be prefixed with our prefix to avoid collisions
prefix_products = set("db".split())
lsst_prefix="lsst-"

# Missing dependencies (these would be transparently installed with pip otherwise)
missing_deps = { # map of conda_name -> [ (pkgtype, conda_name), ... ]
	'pymssql'                  : [('conda', 'cython'), ('pypi', 'setuptools-git')],
	'palpy'                    : [('conda', 'cython'), ('conda', 'numpy')],
	'pyfits'                   : [('pypi', 'stsci.distutils')],
	'stsci.distutils'          : [('pypi', 'd2to1')],
	'sims_catalogs_generation' : [('conda', 'sqlalchemy')],
	'sims_photUtils'           : [('conda', 'scipy'), ('conda', 'astropy')],
}

# Override sha1s
override_gitrev = {
	'sconsUtils': 'u/mjuric/relocation-fixes',
	'webservcommon': 'u/mjuric/DM-2993-never-depend-on-anaconda',
	'healpy': 'u/mjuric/sanitize-flags',
	'log': 'u/mjuric/DM-2995-fix-EINTR-in-testcase',
	'ctrl_events': 'u/mjuric/osx-compatibility',
	'ctrl_orca': 'u/mjuric/typo-fix-in-production_data'
}

# dict with transformations from EUPS to conda package names
eups_to_conda_map = {
	'legacy_configs' : 'legacy_configs'
}

def conda_package_exists(product):
	ret = subprocess.check_output('conda search -f --json %s' % (product), shell=True).strip()
	return ret != "{}"

def gen_pypi_package(name, products, workdir):
	tmpdir = os.path.join(workdir, '_pypi')
	os.makedirs(tmpdir)

	# generate the packages
	retcode = subprocess.call('conda skeleton pypi %(name)s --recursive --output-dir %(pypi)s > %(pypi)s/output.log' % { 'name': name, 'pypi' : tmpdir }, shell=True)
	if retcode:
		raise Exception("conda skeleton returned %d" % retcode)

	# some pypi packages have undeclare dependencies themselves (sigh...)
	deps = add_missing_deps(name, tmpdir)
	if deps:
		# patch the generated meta.yaml file to add the missing dependenceis
		build_req = create_deps_string(deps)
		run_req   = create_deps_string(deps)

		metafn = os.path.join(tmpdir, name, 'meta.yaml')
		with open(metafn) as fp:
			meta = fp.read()

		import re
		meta = re.sub(r'(^requirements:\n  build:)',  r'\1' + build_req, meta, count=1, flags=re.MULTILINE)
		meta = re.sub(r'(^requirements:\n.*^  run:)', r'\1' +   run_req, meta, count=1, flags=re.MULTILINE | re.DOTALL)
		
		with open(metafn, "w") as fp:
			fp.write(meta)

	# see what was generated
	#with open(os.path.join(tmpdir, 'output.log')) as fp:
	#	packages = [ line.split()[-1] for line in fp if line.startswith("Writing recipe for ") ]

	# move into output directory any generated packages that aren't already there
	for package in os.listdir(tmpdir):
		src  = os.path.join(tmpdir, package)
		if not os.path.isdir(src):
			continue

		dest = os.path.join(workdir, package)
		if not os.path.isdir(dest) and not conda_package_exists(package):
			print "MOVING: ", src, dest
			os.rename(src, dest)

			if package not in products:
				products[package] = ProductInfo(package, 'unknown', None, [])

	# delete what remains
	shutil.rmtree(tmpdir)

def add_missing_deps(conda_name, workdir):
	# inject missing dependencies, creating new conda packages if needed
	# returns Conda package names
	deps = []
	for kind, dep in missing_deps.get(conda_name, []):
		print conda_name, ':', kind, dep
		{
			'pypi': gen_pypi_package,
			'conda': lambda dep, products, workdir: None
		}[kind](dep, products, workdir)
		deps.append(dep)

	return deps

def conda_name_for(product):
	# return the conda package name for a product
	conda_name = lsst_prefix + product if product in prefix_products else product
	eups_to_conda_map[product] = conda_name
	return conda_name

if __name__ == "__main__":
	# Generate conda package files and build driver script
	products = OrderedDict()
	os.makedirs(output_dir)
	with open(os.path.join(output_dir, "rebuild.sh"), "w") as fp:
		print >>fp, "set -e"
		for (product, sha, version, deps) in load_manifest('b1467.txt'):
			if product in internal_products: continue
			if product in skip_products: continue

			# override gitrevs (these are temporary hacks/fixes; they should go away when those branches are merged)
			sha = override_gitrev.get(product, sha)

			gen_conda_package(product, sha, version, deps)


		# write out the rebuild script
		comment = '#'
		for product, info in products.iteritems():
			if product == 'sims_photUtils':
				comment = ''
			print >>fp, comment + "(cd 'pkgs/%(conda_name)s' && test -f .done || { echo -n '%(product)s-%(version)s [%(conda_name)s]... ' && conda build . > _build.log 2>&1 && touch .done && echo 'OK' || { echo 'ERROR'; exit -1;} })" % { 
				'product': product, 'version': info.version, 'conda_name': info.conda_name, }
